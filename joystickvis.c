#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Hubs,  S2, MatrxRbtcs, none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     accel,          sensorI2CHiTechnicAccel)
#pragma config(Sensor, S4,     infrared,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_Matrix_S1_1, right_front,   tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_2, flapper,       tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_3, left_back,     tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_4, right_back,    tmotorMatrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S2_1, lift_left,     tmotorMatrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S2_2, lift_right,    tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S2_3, left_front,    tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S2_4, lift_right,    tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoStandard)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_3, grabber,              tServoStandard)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_1, servo5,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_2, servo6,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_3, servo7,               tServoStandard)
#pragma config(Servo,  srvo_Matrix_S2_4, releaser,             tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * @author   Earthquake
 * @link     https://github.com/91-earthquake/oceaan/blob/master/joystickvis.c
 */

// Open a the joystick debugger window
// As soon as the program is run
#pragma DebuggerWindows("joystickGame")

// Include the joystick driver
#include "JoystickDriver.c"

  ////////////
 // Config //
////////////
// Should the steering be reversed or not
#define JOY_REVERSE_STEER false

// Set a value to define a 'Dead zone' on the joystick
// Can be modified, but 5 should be allright
#define JOY_TRESHOLD 5

// Define the boost button
// Make sure to add one
#define JOY_BTN_BOOST 12

// The button to release the balls from the reservoir
#define JOY_BTN_RELEASER 6

// The button to grab a pipe
#define JOY_BTN_GRABBER 5

// The button to start the brush
#define JOY_BTN_BRUSH 4

// The amount of milliseconds to wait
// At the end of the loop
#define JOY_LOOP_DELAY 10

// The value of the JOY_LIMITER
// If the power button isn't pressed,
// The power will be divided by this number
#define JOY_LIMITER 2

// The steering sensitivity,
// the value will be divided by this
#define JOY_STEER_SENSITIVITY 1


task main(){
	        /////////////////////////
	       // Temporary variables //
	      /////////////////////////

	      // A temporary variable to switch the servo's
	bool  switching = false,
				switching2 = false,
				switching3 = false,

	      // Another temporary variable
	      releasebtn = false,
	      releasebtn2 = false,
	      releasebtn3 = false;

	      // Define the variables for each joystick
	int   joy1y1,
	      joy1x1,
	      joy1y2,
	      joy1x2,
	      joy2y1,
	      joy2x1,
	      joy2y2,
	      joy2x2;

	      // Define the variables for the power and the steering,
	      // And the left and the right motor, but engine sounds better
	int   power,
	      steering,
	      left_engine,
	      right_engine;

	// Reset the servo's to
	servo[grabber] = 0;
	servo[releaser]= 255;

	while(true){
		// Get the joystick settings
		getJoystickSettings(joystick);

		// Define the 'Dead Zones' for each axis on each joystick
		// Only set the values if the value exeeds the treshold
		//
		// Joystick one (drivers joystick):
		if (abs(joystick.joy1_y1) > JOY_TRESHOLD) joy1y1 = joystick.joy1_y1;
		else joy1y1 = 0;

		if (abs(joystick.joy1_x1) > JOY_TRESHOLD) joy1x1 = joystick.joy1_x1;
		else joy1x1 = 0;

		if (abs(joystick.joy1_y2) > JOY_TRESHOLD) joy1y2 = joystick.joy1_y2;
		else joy1y2 = 0;

		if (abs(joystick.joy1_x2) > JOY_TRESHOLD) joy1x2 = joystick.joy1_x2;
		else joy1x2 = 0;

		// Joystick two (co-pilot's joystick):
		if (abs(joystick.joy2_y1) > JOY_TRESHOLD) joy2y1 = joystick.joy2_y1;
		else joy2y1 = 0;

		if (abs(joystick.joy2_x1) > JOY_TRESHOLD) joy2x1 = joystick.joy2_x1;
		else joy2x1 = 0;

		if (abs(joystick.joy2_y2) > JOY_TRESHOLD) joy2y2 = joystick.joy2_y2;
		else joy2y2 = 0;

		if (abs(joystick.joy2_x2) > JOY_TRESHOLD) joy2x2 = joystick.joy2_x2;
		else joy2x2 = 0;

		// Normalize the values
		joy1y2 = (joy1y2 * 100) / 128;
		joy1x1 = (joy1x1 * 100) / 128;
		joy2y1 = (joy2y1 * 100) / 128;

		// Assign the y2 variable to the power variable
		power = joy1y2;

		// Assign the x1 variable to the steering variable
		steering = joy1x1;

		// Divide the steering variable by the factor given in JOY_STEER_SENSITIVITY
		steering = steering / JOY_STEER_SENSITIVITY;

		// Only divide the power and the steering
		// by boost if the boost is not pressed on the driver's joystick
		if(!joy1Btn(JOY_BTN_BOOST)){
			power = power / JOY_LIMITER;
			steering = steering / JOY_LIMITER;
		}

		// Assign the power to the variables
		// But first check the reverse_steering bool status
		#if JOY_REVERSE_STEER
			right_engine = power + steering;
			left_engine  = power - steering;
		#else
			right_engine = power - steering;
			left_engine  = power + steering;
		#endif

		// Assign the calculated values to the engines
		motor[left_front] = left_engine;
		motor[left_back] = left_engine;
		motor[right_front] = right_engine;
		motor[right_back] = right_engine;

		// Control the brush
		if(joy1Btn(JOY_BTN_BRUSH) && releasebtn){
			if(switching){
				switching = false;
				motor[flapper] = 100;
			}else{
				switching = true;
				motor[flapper] = 0;
			}
			releasebtn = false;
		}
		if(!joy1Btn(JOY_BTN_BRUSH) && !releasebtn) releasebtn = true;

		// Control the servo
		if(joy1Btn(JOY_BTN_GRABBER) && releasebtn2){
			if(switching2){
				switching2 = false;
				// Dicht
				servo[grabber] = 0;
			}else{
				switching2 = true;
				// Open
				servo[grabber] = 255;
			}
			releasebtn2 = false;
		}
		if(!joy1Btn(JOY_BTN_GRABBER) && !releasebtn2) releasebtn2 = true;

		// Control the servo
		if(joy2Btn(JOY_BTN_RELEASER) && releasebtn3){
			if(switching3){
				switching3 = false;
				// Dicht
				servo[releaser] = 255;
			}else{
				switching3 = true;
				// Open
				servo[releaser] = 130;
			}
			releasebtn3 = false;
		}
		if(!joy2Btn(JOY_BTN_RELEASER) && !releasebtn3) releasebtn3 = true;

		// Control the lift
		motor[lift_left] = joy2y1;
		motor[lift_right] = joy2y1;

		// Wait the amount of milliseconds given above
		wait1Msec(JOY_LOOP_DELAY);
	}
}
