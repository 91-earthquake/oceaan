#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Hubs,  S2, MatrxRbtcs, none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     accel,          sensorI2CHiTechnicAccel)
#pragma config(Sensor, S4,     infrared,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_Matrix_S1_1, right_front,   tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_2, flapper,       tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_3, left_back,     tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_4, right_back,    tmotorMatrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S2_1, lift_left,     tmotorMatrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S2_2, lift_right,    tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S2_3, left_front,    tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S2_4, lift_right,    tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoStandard)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_3, grabber,              tServoStandard)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_1, servo5,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_2, servo6,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_3, servo7,               tServoStandard)
#pragma config(Servo,  srvo_Matrix_S2_4, releaser,             tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * @author   Earthquake
 * @link     https://github.com/91-earthquake/oceaan/blob/master/joystickvis.c
 */

// Open a the joystick debugger window
// As soon as the program is run
#pragma DebuggerWindows("joystickGame")

// Include the joystick driver
#include "JoystickDriver.c"

task main(){
	        /////////////////////////
	       // Temporary variables //
	      /////////////////////////

	      // A temporary variable to switch the servo's
	bool  switching = false,
				switching2 = false,
				switching3 = false,

	      // Another temporary variable
	      releasebtn = false,
	      releasebtn2 = false,
	      releasebtn3 = false;

	        ////////////
	       // Config //
	      ////////////

	      // Reverse the steering, if you turn your joystick right,
	      // and your robot turns left, set to true.
	bool  reverse_steering = false;

	      // Set a value to define a 'Dead zone' on the joystick
	      // Can be modified, but 5 should be allright
	int   treshold = 5,

	      // Define the boost button
	      // Make sure to add one
	      btn_boost = 12,

	      // The button to release the balls from the reservoir
	      btn_releaser = 6,

	      // The button to grab a pipe
	      btn_grabber = 5,

	      // The button to start the brush
	      btn_brush = 4,

	      // The amount of milliseconds to wait
	      // At the end of the loop
	      loop_delay = 10,

	      // The value of the limiter
	      // If the power button isn't pressed,
	      // The power will be divided by this number
	      limiter = 2,

	      // The steering sensitivity,
	      // the value will be divided by this
	      steer_sensitivity = 1;

	      // Define the variables for each joystick
	int   joy1y1,
	      joy1x1,
	      joy1y2,
	      joy1x2,
	      joy2y1,
	      joy2x1,
	      joy2y2,
	      joy2x2;

	      // Define the variables for the power and the steering,
	      // And the left and the right motor, but engine sounds better
	int   power,
	      steering,
	      left_engine,
	      right_engine;

	// Reset the servo's to
	servo[grabber] = 0;
	servo[releaser]= 255;

	while(true){
		// Get the joystick settings
		getJoystickSettings(joystick);

		// Define the 'Dead Zones' for each axis on each joystick
		// Only set the values if the value exeeds the treshold
		//
		// Joystick one (drivers joystick):
		if (abs(joystick.joy1_y1) > treshold) joy1y1 = joystick.joy1_y1;
		else joy1y1 = 0;

		if (abs(joystick.joy1_x1) > treshold) joy1x1 = joystick.joy1_x1;
		else joy1x1 = 0;

		if (abs(joystick.joy1_y2) > treshold) joy1y2 = joystick.joy1_y2;
		else joy1y2 = 0;

		if (abs(joystick.joy1_x2) > treshold) joy1x2 = joystick.joy1_x2;
		else joy1x2 = 0;

		// Joystick two (co-pilot's joystick):
		if (abs(joystick.joy2_y1) > treshold) joy2y1 = joystick.joy2_y1;
		else joy2y1 = 0;

		if (abs(joystick.joy2_x1) > treshold) joy2x1 = joystick.joy2_x1;
		else joy2x1 = 0;

		if (abs(joystick.joy2_y2) > treshold) joy2y2 = joystick.joy2_y2;
		else joy2y2 = 0;

		if (abs(joystick.joy2_x2) > treshold) joy2x2 = joystick.joy2_x2;
		else joy2x2 = 0;

		// Normalize the values
		joy1y2 = (joy1y2 * 100) / 128;
		joy1x1 = (joy1x1 * 100) / 128;
		joy2y1 = (joy2y1 * 100) / 128;

		// Assign the y2 variable to the power variable
		power = joy1y2;

		// Assign the x1 variable to the steering variable
		steering = joy1x1;

		// Divide the steering variable by the factor given in steer_sensitivity
		steering = steering / steer_sensitivity;

		// Only divide the power and the steering
		// by boost if the boost is not pressed on the driver's joystick
		if(!joy1Btn(btn_boost)){
			power = power / limiter;
			steering = steering / limiter;
		}

		// Assign the power to the variables
		// But first check the reverse_steering bool status
		if(reverse_steering){
			right_engine = power + steering;
			left_engine  = power - steering;
		}else{
			right_engine = power - steering;
			left_engine  = power + steering;
		}

		// Assign the calculated values to the engines
		motor[left_front] = left_engine;
		motor[left_back] = left_engine;
		motor[right_front] = right_engine;
		motor[right_back] = right_engine;

		// Control the brush
		if(joy1Btn(btn_brush) && releasebtn){
			if(switching){
				switching = false;
				motor[flapper] = 100;
			}else{
				switching = true;
				motor[flapper] = 0;
			}
			releasebtn = false;
		}
		if(!joy1Btn(btn_brush) && !releasebtn) releasebtn = true;

		// Control the servo
		if(joy1Btn(btn_grabber) && releasebtn2){
			if(switching2){
				switching2 = false;
				// Dicht
				servo[grabber] = 0;
			}else{
				switching2 = true;
				// Open
				servo[grabber] = 255;
			}
			releasebtn2 = false;
		}
		if(!joy1Btn(btn_grabber) && !releasebtn2) releasebtn2 = true;

		// Control the servo
		if(joy2Btn(btn_releaser) && releasebtn3){
			if(switching3){
				switching3 = false;
				// Dicht
				servo[releaser] = 255;
			}else{
				switching3 = true;
				// Open
				servo[releaser] = 130;
			}
			releasebtn3 = false;
		}
		if(!joy2Btn(btn_releaser) && !releasebtn3) releasebtn3 = true;

		// Control the lift
		motor[lift_left] = joy2y1;
		motor[lift_right] = joy2y1;

		// Wait the amount of milliseconds given above
		wait1Msec(loop_delay);
	}
}
