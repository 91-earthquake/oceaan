#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     ACCEL,          sensorI2CHiTechnicAccel)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_1, motorD,        tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_2, motorE,        tmotorMatrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S1_3, motorF,        tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_4, motorG,        tmotorMatrix, PIDControl, encoder)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_3, servo3,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "AdvancedSensors.c"
int getIRValues();
void getAccelValues();
// Declare the x, y, and z values
int x = 0,
	  y = 0,
	  z = 0;

void controllingMotor(int speed)
{
	motor[motorD] = speed;
	motor[motorE] = speed;
	motor[motorF] = speed;
	motor[motorG] = speed;
}

bool goToBeacon()
{
	static bool hasBeaconFound = false;
	bool returnValue = false;
 if (getIRValues() != 5)
{
		if (getIRValues() < 5 ) // Turn Left
		{
			motor[motorD] = -15;
			motor[motorE] = 15;
			motor[motorF] = -15;
			motor[motorG] = 15;
 		} 	else if (getIRValues() > 5)
 		{
   		motor[motorD] = 15;
			motor[motorE] = -15;
			motor[motorF] = 15;
			motor[motorG] = -15;
		}
	}
	else
	{
		controllingMotor(50);
		hasBeaconFound = true;
	}
	if (hasBeaconFound && (getIRValues() == 0))
		{
			returnValue =  true;
		}
	return returnValue;
}


/**
 * Set the x, y and z values
 */
void getAccelValues(){
	getAccel(ACCEL, x, y, z);

	// Normalize the values of the Accel sensor
	if (x > 405) x -= 1024;
	if (y > 405) y -= 1024;
	if (z > 405) z -= 1024;
}

int getIRValues()
{
	int IR_values = sensorValue[IR];
	displayBigTextLine(0,"%4d" ,IR_values);
return IR_values;
}


/**
 * Execute this function when the robot is on the ramp
 */
void isOnRamp(){
	playImmediateTone(1200, 20);
	wait1Msec(200);

// Drive forward
	controllingMotor(20);

	getAccelValues();
	while(x < 0){
		getAccelValues();
		wait1Msec(10);
	}
	/* x > - 60, so on flat ground */



	// And disable them
	controllingMotor(0);

	playImmediateTone(1200, 20);
	wait1Msec(200);
}

/**
 * Execute this function when the robot is on the ground
 */
void isOnGround(){

	playImmediateTone(400, 20);
	wait1Msec(200);
	controllingMotor(10);
	wait1Msec(1000);
}

task main(){
	bool onramp = false;

	// Wait 0.1 seconds to give some time to initialize the values

	wait1Msec(100);
	getAccelValues();

	// Turn on the engines...
	controllingMotor(20);

	// ...wait 2 seconds...
	//wait1Msec(2000);

	for (int g = 0; g<200; g++)
	{
		// 2 sec
		wait1Msec(10);
		getAccelValues();

		if(x < -60){
			onramp = true;
			g = 2001;

		}

	}
	// ...and disable the engines.
	// Get the x, y, and z values
	controllingMotor(0);
	getAccelValues();
	// The robot is on the ramp
		// So execute the isOnRamp function
		if(onramp) {  isOnRamp(); }

		// The robot is on the floor
		// So execute the isOnGround function
		else {isOnGround(); }
		
		controllingMotor(20);
		wait10Msec(100);

		while(!goToBeacon())
		{				
			wait1Msec(1);
		}
				controllingMotor(0);
				playImmediateTone(1000, 20);
				wait10Msec(50);
				playImmediateTone(800, 20);
				wait10Msec(50);
				playImmediateTone(700, 20);
				wait10Msec(50);
				playImmediateTone(400, 20);
				wait10Msec(50);

}
